export const interviewSectionsData = {
  interviewSections: [
    {
      id: 1,
      title: "자기소개",
      icon: "👤",
      description: "면접관에게 자신을 소개하는 방법과 포인트",
      content: `4년차 웹 프론트앤드  개발자 최 혁 입니다.
현재 글로벌 교육 서비스 회사에서 프론트 개발을 담당하고 있습니다.
도메인 관리부터 배포 까지 프론트 전반적인 업무를 리드 하고 있습니다.
프론트팀에 후임 한분이 계시는데 제가 코드 리드하면서 업무분배까지 담당하고 있습니다.
최근에는 백엔드 네스트 환경에서 TypeORM 기반으로 데이터테이블에 접근해 API , 엔드포인트 수정 작업을 하고 있습니다.
궁극적으로 풀스텍 개발자를 지향하고 있습니다.

개발자 이전에는 2년정도 베트남에서 생활하면서 여행사에 근무한 경험이 있습니다.
그 후 국내에 돌아와서 개발자 공부를 독학으로 1년간 하고 개발자 커리어를 시작하게 되었습니다.

개발자를 하게된 이유?는 베트남 생활을 하면서  해외 생활을 지속적으로 하고 싶었습니다. 그래서 어느 나라에서나 제한없이 일할 수 있는 직업을 찾다가  개발자라는 직업을 찾게 되어서 시작하게 되었습니다.

독학으로 한 이유? 그 당시에는 코로나 상황으로 제한적인 환경이였고, 개발 교육이 지금처럼 활성화 되지 않았었고 ,
국비 학원은 제가 그 전 베트남 kmove 스쿨에 참여한 적이 있어 제한되어서
하지 못하였습니다. 그래서 udemy, 인프런 같은 곳에서 온라인 강의를 수강하면서 공부하였습니다.

실패한 프로젝트?
최근에 mcp로 ai를 연결하여 api 문서화 작업을 진행한적이 있었습니다.
호출되는 api 위치, 사용되는 api 위치, 네임등을 정리를 요청하였는데, 문서를 잘 정리해서 결과물을 산출해줬습니다.
하지만 제가 확인한 결과 사용되지 않는 api를 사용되고 있다 하는 경우, 존재하지 않는 경로를 산출하는 경우들이 많았었습니다.
그래서 그 결과물을 가지고 결국은 제가 하나씩 다 확인하고 수정하는 작업을 했습니다.
결론적으로 ai는 지금 휼륭한 도구는 맞지만 ai주도하에 코드는 아직까지는 위험하다고 판단되는 생각을 하게되었습니다.

협업 어떻게 하고있는지?

최근 겪은 어려운점?

올해부터 현재 회사에서 백엔드 개발에도 참여하게 되었는데, 처음에는 간단한 API 수정 작업에서도 많은 코드 리뷰, 피드백을 받으면서 어려움을 겪었습니다.
피드백들을 하나하나 소화하면서 점차 성장했고, 지금은 혼자서 API를 수정하는 작업을 완료 할 수 있는 수준이 되었습니다.
이러한 과정을 통해 풀스텍 개발자에 좀 더 가까워지고 욕심을 가지게 되었습니다.

백엔드를 배워서 좋은점?
그전에는 api를 호출하는 프론트 입장만 알고있었는데 db 구조를 파악하고 api를 직접 수정하다보니 웹 프로세스 개발에 전체적인 큰 그림을 보게 되어서 
백앤드 개발자 혹은 기획자 분들과 소통에서 넓은 시야로 바라볼 수 있게 되었습니다.


`,
    },
    {
      id: 2,
      title: "기술소개",
      icon: "💻",
      description: "기술 스택과 경험에 대한 설명 방법",
      content: `- React.js, Vue.js(또는 Angular) 기반 싱글 페이지 애플리케이션(SPA) 개발
리액트의 가장 큰 특징은 컴포넌트 기반 아키텍처와 Virtual DOM이라고 생각합니다.
특히 컴포넌트 재사용성 덕분에 개발 효율성이 크게 향상되고, Virtual DOM으로 성능 최적화도 자동으로 이뤄진다는 점이 큰 장점입니다.

- * 도메인 관리 ? 
AWS amplify 사용해서 도메인 관리 부터 자동 빌드 배포,환경변수 관리 까지 하고 있습니다. 도메인 구매는 가비아에서 하였고
Next 14버전 리액트 18버전 환경 , Node 20
백엔드는 nest 환경이고 데이터는 postgresql

1. 가비아에서 도메인 구매
2. AWS Route 53에서 호스팅 영역 생성
3. 호스팅 영역에 NS(네임서버)에 4개의 레코드 값들을 가비아 네임서버에 설정
  4. AWS Amplify에서 도메인 추가 
	AWS가 자동으로 처리:
* Route 53에 A 레코드 자동 생성
* SSL 인증서 자동 발급
* CDN 설정
  5. Route 53에서 Amplify 연결
	Amplify에서 제공하는 엔드포인트를 Route 53에 레코드로 추가:  A 레코드 (루트 도메인)

* 자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?
  자바스크립트는 싱글 스레드 언어입니다. 즉, 한 번에 하나의 작업만을 처리할 수 있는 단일 콜 스택을 가집니다. 
  하지만 브라우저나 Node.js 환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다.
  자바스크립트는 브라우저의 Web API나 Node의 libuv, 이벤트 루프, 태스크 큐를 이용하여 비동기 작업을 동시에 처리합니다.
  비동기 작업이 발생하면, 해당 작업(타이머, 네트워크 요청 등)은 브라우저의 Web API에 위임됩니다. 
  예를 들어, setTimeout이나 fetch와 같은 작업이 수행되면 자바스크립트 엔진은 이 작업들을 Web API에 넘기고 다른 코드 실행을 이어갑니다. Web API에서 비동기 작업이 완료되면, 그 작업은 태스크 큐에 들어가 대기합니다.
  이후 이벤트 루프가 콜 스택이 비어있는지 확인한 뒤 태스크 큐에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다. 이러한 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기적으로 작업을 처리하여 다양한 작업을 효율적으로 관리할 수 있습니다. 이 메커니즘 덕분에 UI 인터랙션이 끊기지 않으며, 대기 시간이 필요한 작업도 동시에 실행되는 것과 같이 동작하게 됩니다.

* 디자인 시스템
컴포넌트 기반으로 설게하여 재사용 가능한 UI 컴포넌트를 생성하고 .
디자이너와의 협업에서 토큰 시스템(색상, 타이포그래피, 간격 등)을 정의하고 일관성 있는 UI를 구현

* Next  
SSR ,CSR > 결합한 하이드레이션 방식으로 랜더링 가능
앱 라우터 파일 시스템 기반으로 페이지 라우팅 관리가 매우 편해집니다.
프론트엔드와 실제 백엔드 서버 사이에서 프록시(Proxy) 역할을 수행함으로써 보안을 강화할 수 있습니다.
Next.js의 API 라우트는 클라이언트 컴포넌트가 직접 백엔드 API를 호출하지 않고, Next.js 서버의 API 라우트를 통해 통신하게 만듭니다.
민감 정보 노출 방지

* NEXT 서버
인증 관련 프록시/쿠키 관리 역할 사용
백엔드 API호출
  - 응답받은 토큰을 HttpOnly 쿠키로 설정
보안: 토큰을 HttpOnly 쿠키로 관리해 XSS 공격 방지
프록시: 실제 백엔드 API를 호출하고 쿠키 처리
미들웨어: 클라이언트와 백엔드 사이의 인증 레이어 역할

* Zustand 
도입 이유 > Context Provider의 value가 변경되면, 해당 Provider의 하위에 있는 모든 Consumer(또는 useContext를 사용하는 컴포넌트)는 
value의 특정 값이 필요한지 여부와 관계없이 무조건 리렌더링됩니다.
  러닝 커브도 적으면서 보일러플레이트를 리덕스에 비해 많이 줄일수 있고
  효용성이 높아서 전역 데이터 관리를 위해 사용했습니다.

* contextAPI
프로젝트 규모가 중소 규모였고, Redux의 보일러플레이트가 과하다고 판단
러닝 커브가 낮아 팀원들이 쉽게 적응 가능
전역적으로 필요할때는 글로벌 Container를 적용하여 사용
* contextAPI 단점
공유하는 state값이 변경될때 Props가 전달되지 않는 하위 컴포넌트까지 전부 리랜더링을 시킨다
*기존에는 변경되는  props 전달되는 하위 요소만 리랜더링이 된다.
그래도 쓰는 이유는? Props drilling을 피할 수 있는방법으로 
Context.Provider의 value prop이 변경될 때마다 
해당 Context를 구독하는 모든 하위 컴포넌트가 불필요하게 리렌더링될 수 있어 성능 문제가 발생할 수 있습니다.
물론 React.memo, useCallback, useMemo 등을 활용하여 최적화를 시도할 수 있지만


* Redux: 복잡한 상태 로직이 있는 대규모 프로젝트에서 Redux Toolkit을 활용해 보일러플레이트를 줄이고 효율적으로 상태를 관리했습니다. 

* Open API Generator
Swagger(OpenAPI 명세파일)를 기반으로  클라이언트 코드 자동 생성
프론트엔드에서 생성된 코드로 API 호출
백엔드 api 변경 사항을 프론트에서 즉시 반영이 되서 단일성, 타입 안정성, 개발 편의성
Orval은 API 함수 + React Query 훅까지 자동 생성
Api 문서 자체가 api 스팩이 되는

* React Query를 사용하는 이유를 설명해 주세요.
React Query는 서버 데이터를 쉽게 가져오고, 캐싱하고, 
최신 상태로 유지해주며, 로딩/에러 처리까지 자동으로 해주는 도구입니다.
Api 관리를 위한 다양한 기능들을 손쉽게 쓸 수 있게 제공해 주어서 편리함.

* 반응형 UI 구현 ?

웹앱으로 모바일 반응형 구현하여 pwa 방식으로 배포 했습니다. 768px 기준으로 모바일 ,피씨 버전으로 나누어서 작업했습니다.
처음부터 모바일 버전을 고려한 디자인은 한 소스로 가져갔지만
모바일 버전을 고려되지 않고 진행됐던 페이지들은 모바일 컴포넌트를 따로 작업하였습니다.

* WebSocket 연동 경험 ?
WebSocket은 지속적인 연결을 유지하는 양방향 프로토콜이다.
실시간 채팅에 사용
Socket.IO = 풍부한 기능 제공, 추상화된 편리한 API, 브라우저 호환성 강함 (메모리 사용량 약간 무거움)
이에 비해 
번들 사이즈 절약 (Socket.IO 대비 ~60KB 절약)
서버 리소스 효율성
간단한 메시지 프로토콜로 디버깅 용이
이러한 이유로 웹소켓 선택

* 최적화 경험?
	- contextapi가 다 좋은데 문제점이 공유하는 데이터가 쓰이지 않는 컴포넌트도 
	그 데이터가 변경됨에 따라 리랜더링 된다는거, 그래서 react.memo를 통해 불필요한 리랜더링을 방지했다
	- 전역 상태 변경이 과도하게 발생해 불필요한 리렌더가 있었습니다. 
	Zustand를 도입해 컴포넌트별 구독을 최소화하고 (selector 기반 구독 덕분)
	렌더 횟수가 절반 이하로 줄었습니다.
	- api 호출 방식 변경 : 
		기존에는 메뉴 탭 데이터를 가져올 때, 모든 탭의 데이터를 한 번에 요청하는 API 구조였습니다.		이 방식은 초기 로딩 시 불필요한 데이터까지 내려받아, 첫 화면 렌더링이 늦어지고 네트워크 트래픽이 많았습니다.
		이를 개선하기 위해 API에 path parameter를 추가해 /menu/{tabId} 형태로 필요한 탭 데이터만 요청하도록 변경했습니다.		탭 이동 시 해당 탭 데이터만 호출되도록 로직을 수정했고, 로딩 인디케이터를 적용해 UX를 개선했습니다.
		그 결과 초기 로딩 시간은 약 2초 → 0.8초로 단축되었고, 전체 API 응답 크기도 평균 70% 감소했습니다.

    * Tanstack Query를 사용하는 이유를 설명해 주세요.
React Query는 서버 데이터를 쉽게 가져오고, 캐싱하고, 최신 상태로 유지해주며, 로딩/에러 처리까지 자동으로 해주는 도구입니다.
Api 관리를 위한 다양한 기능들을 손쉽게 쓸 수 있게 제공해 주어서 편리함.

`,
    },
    {
      id: 3,
      title: "회사",
      icon: "🏢",
      description: "회사 선택 기준과 지원 동기 정리",
      content: `
      React/TypeScript
* React의 렌더링 최적화 방법들을 설명해주세요 (memo, useMemo, useCallback 등)
    * 메모이제이션 기술도입하여 불필요한 리랜더링 바지
	- React.memo로 불필요한 리렌더링 방지, useMemo로 계산 결과 캐싱, useCallback으로 함수 참조 최적화. 실제로 대용량 리스트 컴포넌트에서 50% 성능 개선

* TypeScript에서 제네릭을 어떻게 활용하셨나요? 실제 프로젝트 사례로 설명해주세요
    : API 응답 타입을 제네릭으로 정의해서 재사용. ApiResponse<T> 형태로 타입 안정성 확보하면서 중복 코드 제거

- 상태 관리
* 프로젝트에서 사용한 상태 관리 라이브러리와 선택 이유는?
: 전역 상태와 로컬 상태를 어떤 기준으로 구분하시나요?
    * 여러 컴포넌트에서 공유하거나 새로고침 후 유지 필요하면 전역, 아니면 로컬
* 서버 상태와 클라이언트 상태 관리를 어떻게 분리하셨나요?
    : React Query로 서버 상태 관리, 로컬 상태는 useState/Context 활용
아키텍처/설계
* 재사용 가능한 컴포넌트를 설계할 때 중요하게 생각하는 원칙들은?
		:단일 책임 원칙, props 인터페이스 명확히, 스타일은 주입받도록 설계
* 기술 부채가 쌓인 프로젝트를 어떻게 개선해 나가시나요?
* 프론트엔드 아키텍처 개선 경험이 있다면 구체적으로 설명해주세요
		:모놀리식 구조를 도메인별로 분리, 공통 컴포넌트 라이브러리 구축


협업/리더십 관련 질문
코드 리뷰/멘토링
* 주니어 개발자 코드 리뷰 시 어떤 점들을 중점적으로 봐주시나요?
		:비즈니스 로직 명확성, 성능 이슈 , 재사용성, 유지보수성, 코드 가독성, 리팩토링
* 의견 충돌이 있을 때 어떻게 해결하시나요?
    : 데이터나 벤치마크 기반으로 객관적 판단,

디자이너/기획자 협업
* 기획 요구사항이 기술적으로 어려울 때 어떻게 대응하시나요?
    : 단계별 구현 제안하거나 MVP 버전 먼저 개발 후 점진적 개선

문제 해결 경험
* 사용자 경험 개선을 위해 기술적으로 어떤 시도를 해보셨나요?
: 	- api 호출 방식 변경 
    기존에는 api 호출방식이 메뉴 탭 데이터를 한 번에 모두 요청하는 구조였는데, 탭아이디를 파라미터로 받는 형태로 변경하여 필요한 탭 데이터만 요청하도록 개선한 결과, 
    초기 로딩 시간을 2초에서 0.8초로 단축하고 API 응답 크기를 평균 70% 감소시켰습니다

서버에서 데이터를 재요청할 때 React Query의 기본 동작은 data를 undefined로 초기화하기 때문에, 기존 데이터가 사라졌다가 새 데이터로 교체되면서 깜빡임 현상이 발생해 사용자 경험을 저해한다고 판단했습니다.
이를 해결하기 위해 placeholderData: keepPreviousData 옵션을 추가하여 새로운 데이터 로딩 중에도 이전 데이터를 유지하도록 개선했습니다. 결과적으로 사용자는 끊김 없는 자연스러운 데이터 전환을 경험할 수 있게 되었습니다.
특히 페이지네이션이나 필터링 기능에서 효과가 컸습니다

* 제품 성능 모니터링 
    - 주기적으로 계약한 학교 및 교육기관에 찾아가 선생님들과 미팅, 오픈 채팅에 선생님들을 초대해 개선사항을 요청 받으면서
      서비스를 점검 및 수정해 나갔습니다
      기존에 노트 기능에 디폴트 값이 학생에게 노출 상태 값이였는데 선생님들께서는 노트는 민감한 사항이라 기본값이 비노출로 요청하셔서 즉각 수정 응답. 
      대학교 리스트 성적순 혹은 옵션값으로 이름순 까지 추가 요청 받으 후 반영


* RESTful API, 비동기 처리, 상태 관리에 대한 깊은 이해
  - REST 원칙에 따라 자원 기반 URL 설계하고 HTTP 메서드를 적절히 활용해서 직관적인 API 구조를 만들어왔습니다
  - "async/await와 Promise를 활용해서 API 호출과 에러 핸들링을 구현하고, Promise.all로 병렬 처리 최적화를 해봤습니다"
  - "React Query를 통해 비동기 상태 관리하면서 캐싱과 리패치 로직을 구현했고, debounce로 검색 API 최적화도 경험했습니다"
  - "로컬 상태는 Context API, 전역 상태는 Zustand, 서버 상태는 React Query로 구분해서 각각의 특성에 맞게 관리해왔습니다"
  - "Context API는 컴포넌트 간 props drilling 방지용으로, Zustand는 앱 전체 공유 상태용으로 활용해서 효율적인 상태 관리를 구현했습니다"

프로젝트 경험 질문
CI/CD
* 어떤 CI/CD 도구를 사용해보셨고, 파이프라인은 어떻게 구성하셨나요?
AWS Amplify를 사용해서 Git 기반 자동 배포 파이프라인을 구성했습니다. main 브랜치는 프로덕션 환경, qa 브랜치는 테스트 환경으로 분리해서 관리했고,
새로운 피쳐 개발 시에는 qa 브랜치에서 feature 브랜치를 생성해서 작업했습니다.
qa 환경에서 테스트가 완료되면 main 브랜치에 머지해서 프로덕션 배포가 자동으로 이루어지도록 구성했습니다.

* 프론트엔드 성능 측정 도구와 지표들을 어떻게 활용하시나요?
Lighthouse
      `,
    },

    {
      id: 4,
      title: "기타 기술지식",
      icon: "💻",
      description: "다양한 기술 설명",
      content: `
      * 클로저?
	클로저는 함수가 생성될 때의 외부 변수(스코프)를 기억하고, 나중에 그 함수가 실행될 때도 그 변수에 접근할 	수 	있는 기능

* 쓰로틀링: 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것
* 디바운싱: 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것
* DTO ?  클라이언트-서버 간 주고받는 데이터 구조를 정의한 클래스
* Entity? 테이블과 매핑되는 객체

* 인터넷 창에 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요. 
 -  DNS 조회 :  도메인 이름을 IP 주소로 변환 , DNS 서버에 요청하여 www.google.com에 해당하는 IP 주소를 얻습니다.
     두번째로 TCP 연결 수립 : TCP 연결은 두 컴퓨터 간에 데이터를 안전하게 주고받기 위한 통신 경로
     세번째로 HTTP 요청 : 3-way handshake는 클라이언트와 서버가 서로 연결 준비가 되었는지 확인하는 3단계 과정입니다."
    "클라이언트가 연결 요청을 보내고, 서버가 승인하며, 클라이언트가 최종 확인하는 과정입니다."
     네번째로 서버의 응답 

* 이벤트루프
자바스크립트의 이벤트 루프는 자바스크립트가 싱글 스레드 기반 언어임에도 불구하고 비동기 작업을 처리할 수 있게 해주는 중요한 메커니즘
콜 스택 -  현재 실행 중인 함수들이 쌓이는 곳 
태스크 큐 - 비동기 작업이 완료된 후 그 결과를 대기시키는 곳 ( 모든 동기 작업들(콜스택이 비어지면)이 완료된 후에 콜 스택으로 옮겨져 실행됨 )
	- 매크로태스크 : setTimeout(), setInterval()과 같은 일반적인 비동기 작업
	- 마이크로태스크 :Promise.then()과 같이 중요도가 높은 작업들,마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높음

* 자바스크립트 클로저
클로저란, 함수가 선언될 당시의 외부 변수들을 기억하고,
그 함수가 나중에 실행될 때도 해당 변수들에 접근하거나 수정할 수 있게 해주는 기능이다.

* 테일 윈드에서 동적 클래스 적용 안되는 이유
1. 테일 윈드는 정적 문자열만 인식함, 동적으로 생성된 클래스는 인식 안함 
그래서 빌드시 제거


* Next App router > 서버 컴포넌트, 클라이언트 컴포넌트
1. 서버 컴포넌트
서버에서 html(브라우저가 자바스크립트를 실행하기 전에 이미 완성된 HTML을 보여줄 수 있음)을 그려서 브라우저에 전달 (js를 전달하지 않는다)
서버 컴포넌트는 JS 파일까지 전달하진 않음. JS는 필요할 경우에만 로딩되고, 서버 컴포넌트 자체는 JS 번들에 포함되지 않음

2. 클라이언트 컴포넌트
서버에서 기본 html, js번들을  브라우저에 전달 해서 브라우저에서 html을 랜더링한다.
즉 서버 컴포넌트는 초기 로딩화면이 빠르지만 상호작용(js) 불가 하다.
클라이언트는 초기 로딩화면이 오래걸리지만 초기에 JS를 모두 받아오기 때문에 이후 페이지 간 전환이 빠르고 부드러움

* Next.js를 사용하는 이유가 무엇인가요?
번들러 설정, 라우팅 설정 등 추가 세팅 등 복잡한 과정을 방식을 지원해주고
앱 라우팅은 폴더 디렉토리 구조만으로 페이지를 생성해주기때문에  페이지 라우팅 관리를 편리하게 해준다.
next에서는 서버 컴포넌트 안에 상호작용 부분을 클라이언트 컴포넌트로 위치시켜 두 기능이 합쳐질수 있다.
즉 하이드레이션 랜더링 방식이 가능하게 해주는 프레임워크

* 타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요.
interface는 객체의 형태를 확장하는 데 용이한 반면, type은 튜플, 인터섹션, 유니온 등을 이용하여 더 복잡한 타입 정의 및 조합을 표현하는 데 용이합니다.
먼저, interface는 선언 병합을 지원해 여러 번 선언할 수 있어, 주로 객체 타입을 확장할 때 유리합니다. 동일한 이름을 가진 interface를 여러 번 선언하면, 이 속성들이 자동으로 합쳐집니다.
type으로 선언한 경우에는 동일한 이름을 중복 선언하면 에러가 발생합니다. 대신, type은 튜플과 같은 복잡한 타입 표현이 가능하며, 복잡한 타입 조합을 위해 인터섹션(&)과 유니온(|) 연산자를 지원합니다.
정리하자면, interface는 선언 병합을 통해 여러 번 선언이 가능하여 주로 객체 타입을 확장하는 데 유리하며, type은 튜플 등 복잡한 타입을 사용하고 유연한 연산자를 통해 복잡한 타입 조합을 표현하는 데 적합합니다.
*Tip - interface는 기존 객체 타입을 확장 할 수 있어서 라이브러리에 쓰이는 객체 타입을 확장해서 사용할 수 있다. 

- Async와 defer의 차이점
Async는 다운로드 완료 순서대로 실행 (독립적)
Defer는 HTML에 작성된 순서대로 실행


`,
    },
  ],
};
